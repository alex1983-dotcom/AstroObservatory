{
	"nodes":[
		{"id":"e5191af7342f1876","x":960,"y":7360,"width":9920,"height":10703,"type":"group","label":"Роутеры"},
		{"id":"0916eb844345f67f","x":960,"y":-80,"width":9920,"height":7120,"type":"group","label":"Модули моделей базы данных"},
		{"id":"a55d5be6ad9013cb","type":"group","x":-2080,"y":-80,"width":2040,"height":2404,"label":"app/database.py"},
		{"id":"2ee4501041432802","x":-2000,"y":4,"width":760,"height":2160,"type":"file","file":"app/database.py.md"},
		{"id":"27b4436efc50e498","type":"text","text":"## 📚 Разбор файла `database.py`\n\nЭтот файл — **ядро работы с базой данных** в приложении. Он настраивает подключение к БД и предоставляет инструменты для работы с ней.\n\n---\n\n## 📊 Таблица импортов\n\n| Импорт | Назначение | Пояснение |\n|--------|------------|-----------|\n| `from sqlmodel import SQLModel` | Базовый класс для всех моделей | SQLModel объединяет SQLAlchemy ORM и Pydantic валидацию |\n| `from sqlmodel.ext.asyncio.session import AsyncSession` | Асинхронная сессия | Позволяет работать с БД асинхронно (без блокировки) |\n| `from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker` | Создание движка и фабрики сессий | `create_async_engine` — подключение к БД, `async_sessionmaker` — создание сессий |\n| `from sqlalchemy.pool import NullPool` | Управление пулом соединений | Отключает пул соединений (полезно для тестов) |\n| `from typing import AsyncGenerator` | Типизация генераторов | Для аннотации типа в `get_db()` |\n| `import os` | Работа с операционной системой | Чтение переменных окружения |\n| `from dotenv import load_dotenv` | Загрузка .env файла | Читает переменные из `.env` файла |\n\n---\n\n## 📊 Таблица переменных и констант\n\n| Имя | Тип | Значение/Описание |\n|-----|-----|-------------------|\n| `load_dotenv()` | Функция | Загружает переменные из `.env` файла в `os.environ` |\n| `DATABASE_URL` | `str` | URL подключения к базе данных (из `.env`) |\n| `engine` | `AsyncEngine` | Асинхронный движок для работы с БД |\n| `AsyncSessionLocal` | `async_sessionmaker` | Фабрика для создания сессий |\n\n### 🔧 Настройки `engine`:\n\n```python\nengine = create_async_engine(\n    DATABASE_URL,      # URL подключения (например: \"sqlite+aiosqlite:///./astronomy.db\")\n    echo=True,         # Показывать все SQL запросы в консоли (для отладки)\n    future=True,       # Использовать новый стиль SQLAlchemy 2.0\n    poolclass=NullPool # Отключить пул соединений (каждый раз новое соединение)\n)\n```\n\n**Почему `NullPool`?**\n- Для тестов и разработки — каждый запрос создает новое соединение\n- В продакшене обычно используют пул соединений для производительности\n\n### 🔧 Настройки `AsyncSessionLocal`:\n\n```python\nAsyncSessionLocal = async_sessionmaker(\n    engine,                 # Движок для подключения\n    class_=AsyncSession,    # Класс сессии (асинхронный)\n    expire_on_commit=False, # Не \"просрочивать\" объекты после коммита\n    autoflush=False,        # Не автоматически сбрасывать изменения в БД\n    autocommit=False        # Не автоматически коммитить (ручное управление)\n)\n```\n\n**Пояснение настроек:**\n- `expire_on_commit=False` — после сохранения объекты остаются \"живыми\" и доступными\n- `autoflush=False` — изменения не отправляются в БД автоматически, только при `commit()`\n- `autocommit=False` — нужно явно вызывать `commit()` для сохранения\n\n---\n\n## 📊 Таблица функций\n\n### 1️⃣ `get_db()` — Dependency для получения сессии\n\n| Параметр | Тип | Описание |\n|----------|-----|----------|\n| **Возвращает** | `AsyncGenerator[AsyncSession, None]` | Генератор, который выдает сессию |\n\n#### Что делает функция:\n\n```python\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    async with AsyncSessionLocal() as session:  # Создаем сессию\n        try:\n            yield session      # Отдаем сессию вызывающему коду\n            await session.commit()  # Если всё ок — сохраняем изменения\n        except Exception:\n            await session.rollback()  # Если ошибка — откатываем изменения\n            raise\n        finally:\n            await session.close()  # В любом случае закрываем сессию\n```\n\n#### 🎯 Зачем это нужно:\n\nЭто **Dependency** (зависимость) FastAPI. Она автоматически:\n1. Создает сессию перед выполнением запроса\n2. Передает сессию в вашу функцию-маршрут\n3. Коммитит изменения, если всё прошло успешно\n4. Откатывает изменения при ошибке\n5. Закрывает сессию после завершения\n\n#### 📝 Пример использования в маршруте:\n\n```python\nfrom fastapi import Depends\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n@app.get(\"/celestial-bodies/\")\nasync def get_bodies(db: AsyncSession = Depends(get_db)):\n    # db — это сессия, полученная из get_db()\n    result = await db.execute(select(CelestialBody))\n    bodies = result.scalars().all()\n    return bodies\n```\n\n---\n\n### 2️⃣ `init_db()` — Инициализация базы данных\n\n| Параметр | Тип | Описание |\n|----------|-----|----------|\n| **Возвращает** | `None` | Ничего не возвращает |\n\n#### Что делает функция:\n\n```python\nasync def init_db():\n    # Импортируем все модели (чтобы они зарегистрировались в metadata)\n    from app.models import (\n        celestial_body,\n        astronomer,\n        observation,\n        user\n    )\n\n    # Создаем все таблицы в базе данных\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n#### 🎯 Зачем это нужно:\n\n1. **Регистрация моделей** — импорты гарантируют, что все модели \"увидит\" SQLAlchemy\n2. **Создание таблиц** — `SQLModel.metadata.create_all` создает все таблицы в БД\n\n#### 📝 Где вызывается:\n\nВ `app/main.py` в `lifespan`:\n\n```python\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # При запуске приложения\n    await init_db()  # ← Создаем таблицы\n    yield\n    # При остановке приложения\n```\n\n---\n\n## 🔄 Полный цикл работы с базой данных\n\n```mermaid\ngraph TD\n    A[Приложение запускается] --> B[init_db()]\n    B --> C[Создаются таблицы в БД]\n    \n    D[Приходит HTTP запрос] --> E[get_db()]\n    E --> F[Создается сессия]\n    F --> G[Выполняется запрос к БД]\n    G --> H{Успех?}\n    H -->|Да| I[commit()]\n    H -->|Нет| J[rollback()]\n    I --> K[close()]\n    J --> K\n    K --> L[Ответ клиенту]\n```\n\n---\n\n## 📝 Пример полного жизненного цикла\n\n```python\n# 1. Пользователь отправляет запрос\nGET /celestial-bodies/1\n\n# 2. FastAPI вызывает зависимость get_db()\nasync def get_db():\n    async with AsyncSessionLocal() as session:  # ← Создается сессия\n        ...\n        yield session  # ← Сессия передается в маршрут\n\n# 3. Выполняется маршрут\n@app.get(\"/celestial-bodies/{body_id}\")\nasync def get_body(body_id: int, db: AsyncSession = Depends(get_db)):\n    query = select(CelestialBody).where(CelestialBody.id == body_id)\n    result = await db.execute(query)  # ← Запрос к БД\n    body = result.scalar_one_or_none()\n    return body\n\n# 4. После выполнения маршрута\nawait session.commit()   # ← Сохраняем изменения (если были)\nawait session.close()    # ← Закрываем сессию\n\n# 5. Отправляем ответ пользователю\n{\n    \"id\": 1,\n    \"name\": \"Солнце\",\n    \"type\": \"star\",\n    ...\n}\n```\n\n---\n\n## ⚠️ Важные замечания\n\n### 1. **В продакшене используйте миграции!**\n\n```python\n# ❌ НЕ ДЕЛАЙТЕ ТАК в продакшене:\nawait conn.run_sync(SQLModel.metadata.create_all)\n\n# ✅ Вместо этого используйте Alembic:\n# alembic revision --autogenerate -m \"Initial migration\"\n# alembic upgrade head\n```\n\n**Почему?**\n- `create_all` просто создает таблицы, но не отслеживает изменения\n- Alembic создает миграции и позволяет безопасно изменять схему БД\n\n### 2. **Настройки для продакшена:**\n\n```python\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,  # ← Не показывать SQL в продакшене\n    pool_size=10,  # ← Использовать пул соединений\n    max_overflow=20,\n    poolclass=AsyncAdaptedQueuePool  # ← Не NullPool!\n)\n```\n\n---\n\n## 📊 Краткая сводка\n\n| Элемент | Назначение | Когда используется |\n|---------|------------|-------------------|\n| `load_dotenv()` | Загрузка `.env` файла | При запуске приложения |\n| `DATABASE_URL` | URL подключения к БД | При создании `engine` |\n| `engine` | Подключение к БД | В `init_db()` и для создания сессий |\n| `AsyncSessionLocal` | Фабрика сессий | В `get_db()` |\n| `get_db()` | Получение сессии | В каждом маршруте (как `Depends`) |\n| `init_db()` | Создание таблиц | При запуске приложения |\n\n---\n\n**Итог:** Этот файл — фундамент всего приложения. Без него невозможно работать с базой данных. 🏗️","x":-1080,"y":4,"width":940,"height":1000},
		{"id":"cf8f17b9ed2a3a19","x":8800,"y":180,"width":1240,"height":6300,"type":"file","file":"app/models/celestial_body.py.md"},
		{"id":"73dc75e530a05085","x":8760,"y":7583,"width":1280,"height":8457,"type":"file","file":"app/routers/celestial_bodies.py.md"},
		{"id":"2a11e96b1246a0cc","x":6880,"y":3000,"width":1000,"height":3480,"type":"file","file":"app/models/observation.py.md"},
		{"id":"bdce3835438c7a98","x":5200,"y":2642,"width":1040,"height":3838,"type":"file","file":"app/models/astronomer.py.md"},
		{"id":"99a214c20d80e419","x":1200,"y":180,"width":760,"height":660,"type":"file","file":"app/models/__init__.py.md"},
		{"id":"fd66e119693b0c09","x":2240,"y":180,"width":1040,"height":1030,"type":"file","file":"app/models/base.py.md"},
		{"id":"442641384a95e8a5","x":3540,"y":4600,"width":1040,"height":1880,"type":"file","file":"app/models/user.py.md"},
		{"id":"9c7e24a230b60a58","x":1120,"y":7583,"width":880,"height":570,"type":"file","file":"app/routers/__init__.py.md"},
		{"id":"39c61da94667c3e5","x":14720,"y":10560,"width":1120,"height":2165,"type":"file","file":"docs_project/Декораторы маршрутов.md"},
		{"id":"37f7b4973fe4dd43","x":11360,"y":7693,"width":1175,"height":6780,"type":"text","text":"# 🚀 ПУТЬ ОДНОГО ЗАПРОСА (На примере создания планеты)\n\nПредставим, что ты отправляешь запрос на создание Земли.\n\n## 📍 ЭТАП 0: Твой запрос (Клиент)\n\nТы в Swagger UI нажимаешь кнопку, и улетает вот такой пакет данных:\n\n```http\nPOST http://localhost:8000/celestial-bodies/\nContent-Type: application/json\n\n{\n  \"name\": \"Земля\",\n  \"type\": \"planet\",\n  \"mass\": 1.0\n}\n```\n\n**Запомни это.** Это \"посылка\", которую мы отправляем. Теперь посмотрим, что с ней происходит внутри.\n\n---\n\n## 🗺️ ГЛАВНАЯ КАРТА: Как данные текут внутри\n\nВот **вся** архитектура проекта на одной картинке. Сохрани её себе.\n\n```\n┌──────────────────────────────────────────────────────────────────┐\n│                     ИНТЕРНЕТ (Твой браузер)                      │\n│                     Отправляет JSON пакет                        │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  1️⃣  app/main.py  (ВХОДНАЯ ДВЕРЬ)                               │\n│     • Принимает запрос                                           │\n│     • Смотрит: \"Ага, это путь /celestial-bodies/\"                │\n│     • Пересылает в нужный роутер                                 │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  2️⃣  app/routers/celestial_bodies.py  (ПРИЁМЩИК)                │\n│     • Находит функцию create_celestial_body                      │\n│     • Проверяет данные через Pydantic (валидация)                │\n│     • Запрашивает подключение к БД через Depends                 │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  3️⃣  app/database.py  (КЛЮЧ ОТ СКЛАДА)                          │\n│     • Функция get_db() открывает соединение с базой              │\n│     • Даёт \"сессию\" (ручку, за которую можно таскать данные)     │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  4️⃣  app/models/celestial_body.py  (ФОРМА ЗАПИСИ)               │\n│     • CelestialBodyCreate — форма для приёма данных              │\n│     • CelestialBody — форма для хранения в базе                  │\n│     • CelestialBodyRead — форма для выдачи ответа                │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  5️⃣  БАЗА ДАННЫХ (СКЛАД)                                        │\n│     • Сохраняет запись в таблицу celestial_bodies                │\n│     • Присваивает ID (например, 1)                               │\n└────────────────────────────┬─────────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────────┐\n│  6️⃣  ОБРАТНЫЙ ПУТЬ (ОТВЕТ)                                      │\n│     • Роутер берёт данные из БД                                  │\n│     • Оформляет через CelestialBodyRead                          │\n│     • Отправляет JSON тебе обратно                               │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 🔬 РАЗБОР ПО СТРОЧКАМ: Откуда что берётся\n\nДавай пройдём по коду и я покажу, где что лежит.\n\n### 1️⃣ ВХОДНАЯ ДВЕРЬ: `app/main.py`\n\nЗдесь регистрируются все маршруты. FastAPI смотрит сюда первым.\n\n```python\n# app/main.py (строки ~125-129)\n\napp.include_router(celestial_bodies_router)  # ← Подключаем роутер небесных тел\napp.include_router(astronomers_router)       # ← Подключаем роутер астрономов\napp.include_router(observations_router)      # ← Подключаем роутер наблюдений\napp.include_router(auth_router)              # ← Подключаем роутер авторизации\n```\n\n> **Логика:** \"Если запрос начинается с `/celestial-bodies/` — отправляй его в `celestial_bodies_router`\".\n\n---\n\n### 2️⃣ ПРИЁМЩИК: `app/routers/celestial_bodies.py`\n\nЗдесь живёт функция, которая обработает запрос.\n\n```python\n# app/routers/celestial_bodies.py (строка 22)\n\n@router.post(\"/\")  # ← 1. Декоратор: ловит POST запрос на \"/\"\nasync def create_celestial_body(\n    body: CelestialBodyCreate,      # ← 2. Данные из JSON (валидация)\n    db: AsyncSession = Depends(get_db)  # ← 3. Подключение к БД\n):\n    # ... тело функции\n```\n\n#### ❓ Откуда берутся `body` и `db`?\n\n| Параметр | Откуда берётся | Кто заполняет |\n|----------|----------------|---------------|\n| `body` | Из JSON запроса | **FastAPI** автоматически парсит JSON и кладёт в переменную `body` |\n| `db` | Из функции `get_db()` | **Depends()** вызывает функцию и передаёт результат |\n\n> **Важно:** Ты **НЕ** создаёшь эти переменные вручную. FastAPI делает это за тебя до запуска функции!\n\n---\n\n### 3️⃣ КЛЮЧ ОТ СКЛАДА: `app/database.py`\n\nЗдесь создаётся подключение к базе данных.\n\n```python\n# app/database.py (строки 36-50)\n\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    async with AsyncSessionLocal() as session:  # ← Открываем сессию\n        try:\n            yield session  # ← 1. Отдаём сессию в роутер\n            await session.commit()  # ← 3. После функции: сохраняем\n        except Exception:\n            await session.rollback()  # ← 3. При ошибке: отменяем\n        finally:\n            await session.close()  # ← 3. Закрываем сессию\n```\n\n#### 🔍 Механика `yield`:\n\n```\n1. Вызывается get_db()\n       ↓\n2. Доходит до yield session\n       ↓\n3. Сессия передаётся в роутер (в параметр db)\n       ↓\n4. Функция роутера выполняется (создание планеты)\n       ↓\n5. Код возвращается к yield\n       ↓\n6. Выполняется commit() или rollback()\n       ↓\n7. Закрывается сессия\n```\n\n---\n\n### 4️⃣ ФОРМА ЗАПИСИ: `app/models/celestial_body.py`\n\nЗдесь описано, какие данные мы принимаем и как храним.\n\n```python\n# app/models/celestial_body.py\n\nclass CelestialBodyCreate(CelestialBodyBase):  # ← Для входящих данных\n    \"\"\"Схема для создания небесного тела\"\"\"\n    pass  # ← Наследует все поля от базовой модели\n\nclass CelestialBody(CelestialBodyBase, table=True):  # ← Для базы данных\n    \"\"\"Модель для хранения в БД\"\"\"\n    __tablename__ = \"celestial_bodies\"\n    id: int = Field(default=None, primary_key=True)  # ← ID создаётся в БД\n\nclass CelestialBodyRead(CelestialBodyBase):  # ← Для ответа клиенту\n    \"\"\"Схема для ответа\"\"\"\n    id: int\n    created_at: datetime\n    parent_name: Optional[str] = None  # ← Вычисляемое поле\n```\n\n#### 🔄 Превращение данных:\n\n```\n1. Клиент присылает JSON\n       ↓\n2. FastAPI создаёт объект CelestialBodyCreate\n   {\"name\": \"Земля\", \"type\": \"planet\"}\n       ↓\n3. Роутер создаёт объект CelestialBody (для БД)\n   CelestialBody(name=\"Земля\", type=\"planet\")\n       ↓\n4. База данных сохраняет и добавляет ID\n   {\"id\": 1, \"name\": \"Земля\", \"type\": \"planet\"}\n       ↓\n5. Роутер создаёт объект CelestialBodyRead (для ответа)\n   {\"id\": 1, \"name\": \"Земля\", \"type\": \"planet\", \"parent_name\": None}\n       ↓\n6. FastAPI превращает в JSON и отправляет клиенту\n```\n\n---\n\n## 🎬 ПОЛНЫЙ СЦЕНАРИЙ: Пошагово\n\nДавай пройдём весь путь **одного запроса** по шагам.\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 1: ТЫ нажимаешь \"Execute\" в Swagger UI                     │\n│  Отправляется: POST /celestial-bodies/                          │\n│  Тело: {\"name\": \"Земля\", \"type\": \"planet\", \"mass\": 1.0}         │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 2: main.py получает запрос                                 │\n│  Смотрит: \"Путь /celestial-bodies/ → это celestial_bodies_router\"│\n│  Пересылает туда                                                │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 3: routers/celestial_bodies.py находит функцию             │\n│  @router.post(\"/\") → create_celestial_body()                    │\n│                                                                 │\n│  FastAPI делает магию:                                          │\n│  • JSON → body (CelestialBodyCreate)                            │\n│  • Depends(get_db) → db (AsyncSession)                          │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 4: database.py открывает сессию                            │\n│  get_db() → yield session                                       │\n│  Сессия передана в роутер                                       │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 5: Выполняется код функции                                 │\n│                                                                 │\n│  # Проверка уникальности                                        │\n│  query = select(CelestialBody).where(CelestialBody.name == ...) │\n│  existing = await db.execute(query)                             │\n│                                                                 │\n│  # Создание объекта                                             │\n│  db_body = CelestialBody(**body.model_dump())                   │\n│  db.add(db_body)                                                │\n│                                                                 │\n│  # Сохранение                                                   │\n│  await db.commit()                                              │\n│  await db.refresh(db_body)  # ← Получаем ID из БД               │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 6: Формирование ответа                                     │\n│                                                                 │\n│  response = CelestialBodyRead(**db_body.model_dump())           │\n│  response.parent_name = ...  # ← Добавляем вычисляемые поля     │\n│  return response                                                │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 7: FastAPI сериализует ответ в JSON                        │\n│                                                                 │\n│  {                                                              │\n│    \"id\": 1,                                                     │\n│    \"name\": \"Земля\",                                             │\n│    \"type\": \"planet\",                                            │\n│    \"mass\": 1.0,                                                 │\n│    \"parent_name\": null                                          │\n│  }                                                              │\n│                                                                 │\n│  Статус: 201 Created                                            │\n└────────────────────────────┬────────────────────────────────────┘\n                             │\n                             ▼\n┌─────────────────────────────────────────────────────────────────┐\n│  ШАГ 8: Ты видишь ответ в Swagger UI ✅                         │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 🧩 СИНАКСИС: Простые объяснения\n\nВот таблица-шпаргалка по тому, что тебя путает.\n\n| Код | Что это | Простыми словами |\n|-----|---------|------------------|\n| `@router.post(\"/\")` | Декоратор | «Прикрепи эту функцию к адресу /» |\n| `async def` | Асинхронная функция | «Функция, которая может ждать (БД, сеть) не блокируя всё» |\n| `await db.execute()` | Ожидание | «Жди, пока база данных ответит» |\n| `Depends(get_db)` | Зависимость | «Перед запуском функции вызови get_db() и дай мне результат» |\n| `body: CelestialBodyCreate` | Типизация | «В этой переменной будет объект такой-то схемы» |\n| `**body.model_dump()` | Распаковка | «Преврати объект в словарь и передай как аргументы» |\n| `yield` | Генератор | «Дай значение сейчас, а остальной код выполни потом» |\n| `response_model=...` | Модель ответа | «FastAPI, проверь ответ по этой схеме перед отправкой» |\n\n---\n\n## 🎯 ЗАДАНИЕ ДЛЯ ТЕБЯ (очень простое)\n\nЧтобы закрепить, сделай **одно** действие:\n\n1.  Открой `app/routers/celestial_bodies.py`\n2.  Найди функцию `create_celestial_body`\n3.  Найди в ней **3 места**, где происходит магия:\n    *   Где принимается `body`?\n    *   Где берётся `db`?\n    *   Где данные сохраняются в БД?\n\nНапиши мне **номера строк** (или скопируй код этих мест), и я подтвержу, что ты нашёл правильно.\n\n---\n"},
		{"id":"0ec11a2f66a6bd64","x":6630,"y":5720,"width":250,"height":93,"color":"5","type":"text","text":"Схема в Swagger"},
		{"id":"32d71c9b6d6f33d3","x":8380,"y":8600,"width":380,"height":140,"color":"5","type":"text","text":"СХЕМА  ВХОДА  - принимает данные от пользователя\n\n```\nbody: CelestialBodyCreate,\n```"},
		{"id":"9e0a2b583fa82bcf","x":8550,"y":5160,"width":250,"height":120,"color":"5","type":"text","text":"Схема используема в Swagger"},
		{"id":"1e0edb839c2fbc1c","x":9340,"y":9040,"width":340,"height":80,"color":"3","type":"text","text":"`result.scalar_one_or_none()`  - Получить одну запись или None"},
		{"id":"7f61592ae113c6a3","x":6451,"y":8476,"width":369,"height":91,"color":"5","type":"text","text":"Данные из JSON (валидация)Session\nСессия БД (автоматически)"},
		{"id":"390d3ad24ad89748","x":6504,"y":8647,"width":316,"height":79,"color":"1","type":"text","text":"Выполняем запрос ->\nберем одну запись или None ->"},
		{"id":"afbe9aa3189bebaa","x":6756,"y":7583,"width":1060,"height":7657,"type":"file","file":"app/routers/observations.py.md"},
		{"id":"ab135ecc2248476b","x":2703,"y":7693,"width":1040,"height":5450,"type":"file","file":"app/routers/auth.py.md"},
		{"id":"de4413291ec91e04","x":4334,"y":7693,"width":1120,"height":6770,"type":"file","file":"app/routers/astronomers.py.md"},
		{"id":"1910ed265db438c7","x":5763,"y":11172,"width":993,"height":756,"color":"4","type":"text","text":"# 🎯 ПОСТРОЧНЫЙ РАЗБОР: `read_observation`\n\nПонимаю тебя! Давай разберём **КАЖДУЮ СТРОКУ, КАЖДЫЙ СИМВОЛ**. Я объясню так, чтобы точно дошло.\n\n---\n\n## 📁 ПОЛНЫЙ КОД С НОМЕРАМИ СТРОК\n\n```python\n# Строка 1-4: Декоратор маршрута\n@router.get(\n    \"/{observation_id}\",\n    response_model=ObservationRead,\n    summary=\"Получить наблюдение по ID\"\n)\n\n# Строка 5-8: Функция-обработчик\nasync def read_observation(\n    observation_id: int,\n    db: AsyncSession = Depends(get_db)\n):\n\n# Строка 9: Документация функции\n    \"\"\"Получение наблюдения по ID\"\"\"\n\n# Строка 10-13: Создание SQL запроса\n    query = select(Observation).where(Observation.id == observation_id)\n    result = await db.execute(query)\n    observation = result.scalar_one_or_none()\n\n# Строка 14-18: Проверка на существование\n    if not observation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Наблюдение с ID {observation_id} не найдено\"\n        )\n\n# Строка 19-20: Создание ответа\n    response = ObservationRead(**observation.model_dump())\n\n# Строка 21-24: Запрос астронома\n    astro_query = select(Astronomer).where(Astronomer.id == observation.astronomer_id)\n    astro_result = await db.execute(astro_query)\n    astronomer = astro_result.scalar_one_or_none()\n\n# Строка 25-28: Запрос небесного тела\n    body_query = select(CelestialBody).where(CelestialBody.id == observation.celestial_body_id)\n    body_result = await db.execute(body_query)\n    celestial_body = body_result.scalar_one_or_none()\n\n# Строка 29-30: Заполнение вычисляемых полей\n    response.astronomer_name = f\"{astronomer.first_name} {astronomer.last_name}\" if astronomer else None\n    response.celestial_body_name = celestial_body.name if celestial_body else None\n\n# Строка 31: Возврат ответа\n    return response\n```\n\n---\n\n## 🔍 РАЗБОР ПОСТРОЧНО: ДО МЕЛОЧЕЙ\n\n---\n\n# ЧАСТЬ 1: ДЕКОРАТОР (строки 1-4)\n\n```python\n@router.get(\n    \"/{observation_id}\",\n    response_model=ObservationRead,\n    summary=\"Получить наблюдение по ID\"\n)\n```\n\n### Строка 1: `@router.get(`\n\n| Символ | Что означает |\n|--------|--------------|\n| `@` | Это **декоратор** — специальная конструкция Python |\n| `router` | Объект `APIRouter`, созданный в начале файла |\n| `.get` | Метод для **GET-запросов** (получение данных) |\n| `(` | Начало параметров декоратора |\n\n**Что это делает:**\n```\nГоворит FastAPI: \"Когда придёт GET-запрос на этот URL — \nвыполни функцию ниже\"\n```\n\n---\n\n### Строка 2: `    \"/{observation_id}\",`\n\n| Символ | Что означает |\n|--------|--------------|\n| `\"` | Начало строки |\n| `/` | Начало пути URL |\n| `{observation_id}` | **Path параметр** — переменная в URL |\n| `\"` | Конец строки |\n| `,` | Разделитель параметров |\n\n**Что это делает:**\n```\nURL будет выглядеть так: /observations/1\n                           /observations/42\n                           /observations/999\n\nЧисло в URL попадёт в переменную observation_id\n```\n\n**Пример:**\n```\nКлиент запрашивает: GET /observations/5\n                          ↓\nobservation_id = 5  (автоматически преобразуется в int)\n```\n\n> ⚠️ **Важно:** Если клиент отправит `/observations/abc`, FastAPI вернёт ошибку 422, потому что `abc` нельзя превратить в `int`!\n\n---\n\n### Строка 3: `    response_model=ObservationRead,`\n\n| Часть | Что означает |\n|-------|--------------|\n| `response_model=` | Параметр декоратора |\n| `ObservationRead` | **Схема Pydantic** для ответа |\n\n**Что это делает:**\n```\n1. FastAPI проверит ответ через эту схему\n2. В Swagger UI будет показан формат ответа\n3. Лишние поля (например, hashed_password) будут удалены\n```\n\n**Пример ответа:**\n```json\n{\n  \"id\": 1,\n  \"astronomer_id\": 5,\n  \"celestial_body_id\": 3,\n  \"observation_date\": \"2024-01-15T20:00:00\",\n  \"astronomer_name\": \"Иван Петров\",      ← вычисляемое поле\n  \"celestial_body_name\": \"Марс\"          ← вычисляемое поле\n}\n```\n\n---\n\n### Строка 4: `    summary=\"Получить наблюдение по ID\"`\n\n| Часть | Что означает |\n|-------|--------------|\n| `summary=` | Заголовок для Swagger UI |\n| `\"Получить наблюдение по ID\"` | Текст заголовка |\n\n**Что это делает:**\n```\nВ Swagger UI будет написано:\n┌─────────────────────────────────────────┐\n│ GET /observations/{observation_id}      │\n│ ─────────────────────────────────────── │\n│ Получить наблюдение по ID               │ ← summary\n└─────────────────────────────────────────┘\n```\n\n---\n\n### Строка 4: `)`\n\n| Символ | Что означает |\n|--------|--------------|\n| `)` | Конец параметров декоратора |\n\n---\n\n# ЧАСТЬ 2: ФУНКЦИЯ (строки 5-8)\n\n```python\nasync def read_observation(\n    observation_id: int,\n    db: AsyncSession = Depends(get_db)\n):\n```\n\n### Строка 5: `async def read_observation(`\n\n| Слово | Что означает |\n|-------|--------------|\n| `async` | **Асинхронная функция** — может использовать `await` |\n| `def` | Объявление функции (definition) |\n| `read_observation` | Имя функции |\n| `(` | Начало параметров |\n\n**Почему `async`?**\n```\nПотому что мы работаем с базой данных — это I/O операция.\nПока БД отвечает, сервер может обрабатывать другие запросы.\n```\n\n---\n\n### Строка 6: `    observation_id: int,`\n\n| Часть | Что означает |\n|-------|--------------|\n| `observation_id` | Имя переменной |\n| `: int` | **Аннотация типа** — только целые числа |\n| `,` | Разделитель параметров |\n\n**Откуда берётся значение?**\n```\nИз URL! Если запрос: GET /observations/5\n                         ↓\n              observation_id = 5\n```\n\n**Что если отправить не число?**\n```\nGET /observations/abc\n       ↓\nFastAPI вернёт ошибку 422:\n{\n  \"detail\": [\n    {\n      \"type\": \"int_parsing\",\n      \"msg\": \"Input should be a valid integer\"\n    }\n  ]\n}\n```\n\n---\n\n### Строка 7: `    db: AsyncSession = Depends(get_db)`\n\n| Часть | Что означает |\n|-------|--------------|\n| `db` | Имя переменной |\n| `: AsyncSession` | Тип — асинхронная сессия БД |\n| `=` | Присваивание значения |\n| `Depends(get_db)` | **Dependency Injection** |\n\n**Что делает `Depends(get_db)`?**\n```\n┌─────────────────────────────────────────────────────────────┐\n│  1. FastAPI видит Depends(get_db)                           │\n│       ↓                                                      │\n│  2. Вызывает функцию get_db() из app/database.py            │\n│       ↓                                                      │\n│  3. get_db() создаёт сессию БД и делает yield session       │\n│       ↓                                                      │\n│  4. Эта сессия передаётся в параметр db                     │\n│       ↓                                                      │\n│  5. После выполнения функции: commit() + close()            │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Почему не создать сессию напрямую?**\n```\nПотому что Depends() автоматически:\n• Создаёт сессию\n• Закрывает сессию после запроса\n• Делает rollback при ошибке\n• Переиспользует код (не нужно писать в каждой функции)\n```\n\n---\n\n### Строка 8: `):`\n\n| Символ | Что означает |\n|--------|--------------|\n| `)` | Конец параметров функции |\n| `:` | Начало тела функции |\n\n---\n\n# ЧАСТЬ 3: ДОКУМЕНТАЦИЯ (строка 9)\n\n```python\n    \"\"\"Получение наблюдения по ID\"\"\"\n```\n\n| Символ | Что означает |\n|--------|--------------|\n| `\"\"\"` | Начало **docstring** (документационная строка) |\n| `Получение наблюдения по ID` | Описание функции |\n| `\"\"\"` | Конец docstring |\n\n**Что это делает:**\n```\n• Отображается в Swagger UI как описание эндпоинта\n• Помогает другим разработчикам понять, что делает функция\n• Можно использовать многострочный текст\n```\n\n---\n\n# ЧАСТЬ 4: SQL ЗАПРОС (строки 10-13)\n\n```python\n    query = select(Observation).where(Observation.id == observation_id)\n    result = await db.execute(query)\n    observation = result.scalar_one_or_none()\n```\n\n### Строка 10: `    query = select(Observation).where(Observation.id == observation_id)`\n\n**Разбор по частям:**\n\n| Часть | Что означает | SQL-эквивалент |\n|-------|--------------|----------------|\n| `query =` | Создаём переменную | — |\n| `select(Observation)` | SELECT запрос к таблице | `SELECT * FROM observations` |\n| `.where(...)` | Добавляем условие | `WHERE ...` |\n| `Observation.id` | Поле id в таблице | `observations.id` |\n| `==` | Сравнение | `=` |\n| `observation_id` | Переменная из параметра функции | `5` |\n\n**Итоговый SQL:**\n```sql\nSELECT * FROM observations WHERE id = 5\n```\n\n**Почему `==` а не `=`?**\n```\nПотому что это Python, а не SQL!\nВ Python сравнение всегда ==\nSQLModel сам превратит это в SQL =\n```\n\n---\n\n### Строка 11: `    result = await db.execute(query)`\n\n**Разбор по частям:**\n\n| Часть | Что означает |\n|-------|--------------|\n| `result =` | Переменная для результата |\n| `await` | **Ждать** завершения асинхронной операции |\n| `db.execute(query)` | Выполнить SQL запрос |\n\n**Почему `await`?**\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Без await:                                                 │\n│  • Код не ждёт ответа от БД                                 │\n│  • Пытается продолжить выполнение сразу                     │\n│  • Ошибка: \"coroutine was never awaited\"                    │\n│                                                             │\n│  С await:                                                   │\n│  • Код ждёт ответ от БД                                     │\n│  • Только потом продолжает выполнение                       │\n│  • Всё работает правильно ✅                                │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Что возвращает `execute()`?**\n```\nОбъект Result, который содержит:\n• Все найденные записи\n• Методы для извлечения данных (scalar, all, etc.)\n```\n\n---\n\n### Строка 12: `    observation = result.scalar_one_or_none()`\n\n**Разбор по частям:**\n\n| Часть | Что означает |\n|-------|--------------|\n| `observation =` | Переменная для записи |\n| `result.` | Метод объекта Result |\n| `scalar_one_or_none()` | Получить одну запись или None |\n\n**Что делает `scalar_one_or_none()`?**\n\n| Ситуация | Что вернёт |\n|----------|------------|\n| Найдена 1 запись | Объект `Observation` |\n| Найдено 0 записей | `None` |\n| Найдено >1 записей | Ошибка (но у нас id уникальный) |\n\n**Почему не `scalar()`?**\n```\nscalar() → выбросит ошибку, если запись не найдена\nscalar_one_or_none() → вернёт None, если не найдено\n\nМы хотим сами обработать случай \"не найдено\" → 404 ошибка\n```\n\n---\n\n# ЧАСТЬ 5: ПРОВЕРКА НА СУЩЕСТВОВАНИЕ (строки 14-18)\n\n```python\n    if not observation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Наблюдение с ID {observation_id} не найдено\"\n        )\n```\n\n### Строка 14: `    if not observation:`\n\n| Часть | Что означает |\n|-------|--------------|\n| `if` | Условие |\n| `not` | Отрицание |\n| `observation` | Переменная с записью |\n\n**Что это значит:**\n```\nЕсли observation == None → условие истинно → выполняем блок if\nЕсли observation == объект → условие ложно → пропускаем блок if\n```\n\n**Пример:**\n```python\nobservation = None\nif not observation:  # ← True, выполняем код внутри\n    print(\"Не найдено!\")\n\nobservation = <Observation object>\nif not observation:  # ← False, пропускаем код внутри\n    print(\"Не найдено!\")\n```\n\n---\n\n### Строка 15: `        raise HTTPException(`\n\n| Часть | Что означает |\n|-------|--------------|\n| `raise` | **Выбросить** исключение (ошибку) |\n| `HTTPException` | Класс HTTP-ошибки FastAPI |\n| `(` | Начало параметров |\n\n**Что делает `raise`?**\n```\n• Прерывает выполнение функции\n• Возвращает ошибку клиенту\n• Код после raise НЕ выполняется\n```\n\n---\n\n### Строка 16: `            status_code=status.HTTP_404_NOT_FOUND,`\n\n| Часть | Что означает |\n|-------|--------------|\n| `status_code=` | Параметр ошибки |\n| `status.` | Модуль status из FastAPI |\n| `HTTP_404_NOT_FOUND` | Константа = 404 |\n\n**Почему 404?**\n```\n404 = Ресурс не найден\nКлиент понимает: \"Такого наблюдения нет в базе\"\n```\n\n---\n\n### Строка 17: `            detail=f\"Наблюдение с ID {observation_id} не найдено\"`\n\n| Часть | Что означает |\n|-------|--------------|\n| `detail=` | Сообщение ошибки |\n| `f\"...\"` | **f-строка** — форматированная строка |\n| `{observation_id}` | Вставка переменной в строку |\n\n**Что такое f-строка?**\n```python\nobservation_id = 5\n\n# Без f-строки:\n\"Наблюдение с ID \" + str(observation_id) + \" не найдено\"\n\n# С f-строкой (проще!):\nf\"Наблюдение с ID {observation_id} не найдено\"\n\n# Результат:\n\"Наблюдение с ID 5 не найдено\"\n```\n\n---\n\n### Строка 18: `        )`\n\n| Символ | Что означает |\n|--------|--------------|\n| `)` | Конец параметров HTTPException |\n\n**Что получит клиент:**\n```json\n{\n  \"detail\": \"Наблюдение с ID 5 не найдено\"\n}\n```\n\n---\n\n# ЧАСТЬ 6: СОЗДАНИЕ ОТВЕТА (строка 20)\n\n```python\n    response = ObservationRead(**observation.model_dump())\n```\n\n### Разбор по частям:\n\n| Часть | Что означает |\n|-------|--------------|\n| `response =` | Переменная для ответа |\n| `ObservationRead(...)` | Создание объекта схемы ответа |\n| `observation.` | Объект из БД |\n| `model_dump()` | Превратить в словарь |\n| `**` | Распаковать словарь в аргументы |\n\n**Почему так сложно?**\n```\n┌─────────────────────────────────────────────────────────────┐\n│  observation — это объект модели БД                         │\n│  ObservationRead — это схема для ответа                     │\n│                                                             │\n│  Нельзя передать объект напрямую!                           │\n│  Нужно: объект → dict → новый объект                        │\n│                                                             │\n│  observation.model_dump() → {\"id\": 1, \"astronomer_id\": 5}   │\n│  **dict → id=1, astronomer_id=5                             │\n│  ObservationRead(id=1, astronomer_id=5) → готово!           │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Пример:**\n```python\n# observation из БД:\nobservation = Observation(id=1, astronomer_id=5, celestial_body_id=3)\n\n# model_dump():\n{\"id\": 1, \"astronomer_id\": 5, \"celestial_body_id\": 3}\n\n# ** распаковка:\nObservationRead(id=1, astronomer_id=5, celestial_body_id=3)\n\n# response:\nresponse = ObservationRead(...)  # ← готовый объект\n```\n\n---\n\n# ЧАСТЬ 7: ЗАПРОС АСТРОНОМА (строки 21-23)\n\n```python\n    astro_query = select(Astronomer).where(Astronomer.id == observation.astronomer_id)\n    astro_result = await db.execute(astro_query)\n    astronomer = astro_result.scalar_one_or_none()\n```\n\n### Почему это нужно?\n\n```\nВ таблице observations хранятся только ID:\n┌──────────────────────────────────────────┐\n│ observations                             │\n│ id | astronomer_id | celestial_body_id  │\n│ 1  | 5             | 3                  │\n└──────────────────────────────────────────┘\n\nКлиент хочет видеть ИМЕНА, а не ID!\nНужно сделать дополнительный запрос к таблице astronomers\n```\n\n### Строка 21: `    astro_query = select(Astronomer).where(Astronomer.id == observation.astronomer_id)`\n\n| Часть | Что означает | SQL |\n|-------|--------------|-----|\n| `astro_query =` | Переменная для запроса | — |\n| `select(Astronomer)` | SELECT из таблицы astronomers | `SELECT * FROM astronomers` |\n| `.where(...)` | Условие | `WHERE ...` |\n| `Astronomer.id` | Поле id | `astronomers.id` |\n| `observation.astronomer_id` | ID из наблюдения | `5` |\n\n**Итоговый SQL:**\n```sql\nSELECT * FROM astronomers WHERE id = 5\n```\n\n---\n\n### Строка 22: `    astro_result = await db.execute(astro_query)`\n\n| Часть | Что означает |\n|-------|--------------|\n| `astro_result =` | Переменная для результата |\n| `await db.execute()` | Выполнить запрос к БД |\n\n**То же самое, что в строке 11!**\n\n---\n\n### Строка 23: `    astronomer = astro_result.scalar_one_or_none()`\n\n| Часть | Что означает |\n|-------|--------------|\n| `astronomer =` | Переменная для астронома |\n| `scalar_one_or_none()` | Получить одну запись или None |\n\n**То же самое, что в строке 12!**\n\n---\n\n# ЧАСТЬ 8: ЗАПРОС НЕБЕСНОГО ТЕЛА (строки 25-27)\n\n```python\n    body_query = select(CelestialBody).where(CelestialBody.id == observation.celestial_body_id)\n    body_result = await db.execute(body_query)\n    celestial_body = body_result.scalar_one_or_none()\n```\n\n**Абсолютно то же самое, что для астронома!**\n\nТолько теперь запрашиваем таблицу `celestial_bodies`:\n\n```sql\nSELECT * FROM celestial_bodies WHERE id = 3\n```\n\n---\n\n# ЧАСТЬ 9: ЗАПОЛНЕНИЕ ВЫЧИСЛЯЕМЫХ ПОЛЕЙ (строки 29-30)\n\n```python\n    response.astronomer_name = f\"{astronomer.first_name} {astronomer.last_name}\" if astronomer else None\n    response.celestial_body_name = celestial_body.name if celestial_body else None\n```\n\n### Строка 29: `    response.astronomer_name = f\"{astronomer.first_name} {astronomer.last_name}\" if astronomer else None`\n\n**Это тернарный оператор!**\n\n| Часть | Что означает |\n|-------|--------------|\n| `response.astronomer_name =` | Присвоить значение полю |\n| `f\"{...} {...}\"` | f-строка с двумя переменными |\n| `astronomer.first_name` | Имя астронома из БД |\n| `astronomer.last_name` | Фамилия астронома из БД |\n| `if astronomer else None` | Если астроном есть → имя, иначе → None |\n\n**Развёрнутая версия:**\n```python\nif astronomer:  # Если астроном найден\n    response.astronomer_name = f\"{astronomer.first_name} {astronomer.last_name}\"\nelse:  # Если астроном не найден\n    response.astronomer_name = None\n```\n\n**Пример:**\n```python\nastronomer.first_name = \"Иван\"\nastronomer.last_name = \"Петров\"\n\n# Результат:\nresponse.astronomer_name = \"Иван Петров\"\n```\n\n---\n\n### Строка 30: `    response.celestial_body_name = celestial_body.name if celestial_body else None`\n\n**То же самое, но проще:**\n\n| Часть | Что означает |\n|-------|--------------|\n| `response.celestial_body_name =` | Присвоить значение полю |\n| `celestial_body.name` | Название небесного тела |\n| `if celestial_body else None` | Если есть → название, иначе → None |\n\n**Пример:**\n```python\ncelestial_body.name = \"Марс\"\n\n# Результат:\nresponse.celestial_body_name = \"Марс\"\n```\n\n---\n\n# ЧАСТЬ 10: ВОЗВРАТ ОТВЕТА (строка 31)\n\n```python\n    return response\n```\n\n| Часть | Что означает |\n|-------|--------------|\n| `return` | Вернуть значение из функции |\n| `response` | Объект ObservationRead |\n\n**Что происходит после return?**\n```\n┌─────────────────────────────────────────────────────────────┐\n│  1. FastAPI получает объект response                        │\n│       ↓                                                      │\n│  2. Автоматически превращает в JSON через Pydantic          │\n│       ↓                                                      │\n│  3. Отправляет клиенту с статусом 200 OK                    │\n│       ↓                                                      │\n│  4. Клиент получает:                                        │\n│       {                                                      │\n│         \"id\": 1,                                             │\n│         \"astronomer_name\": \"Иван Петров\",                    │\n│         \"celestial_body_name\": \"Марс\",                       │\n│         ...                                                  │\n│       }                                                      │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 🎯 ИТОГОВАЯ СХЕМА ВСЕГО ПРОЦЕССА\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│  1️⃣ КЛИЕНТ ОТПРАВЛЯЕТ:                                      │\n│     GET /observations/5                                      │\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  2️⃣ FASTAPI НАХОДИТ ФУНКЦИЮ:                                 │\n│     read_observation(observation_id=5, db=...)               │\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  3️⃣ ЗАПРОС К БД (наблюдение):                               │\n│     SELECT * FROM observations WHERE id = 5                  │\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  4️⃣ ПРОВЕРКА:                                                │\n│     Если не найдено → 404 ошибка                             │\n│     Если найдено → продолжаем                                │\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  5️⃣ ЗАПРОС К БД (астроном):                                 │\n│     SELECT * FROM astronomers WHERE id = observation.astronomer_id\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  6️⃣ ЗАПРОС К БД (небесное тело):                            │\n│     SELECT * FROM celestial_bodies WHERE id = observation.celestial_body_id\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  7️⃣ СОЗДАНИЕ ОТВЕТА:                                         │\n│     ObservationRead + astronomer_name + celestial_body_name  │\n└────────────────────────────┬─────────────────────────────────┘\n                             │\n                             ▼\n┌──────────────────────────────────────────────────────────────┐\n│  8️⃣ КЛИЕНТ ПОЛУЧАЕТ:                                         │\n│     {                                                        │\n│       \"id\": 5,                                               │\n│       \"astronomer_name\": \"Иван Петров\",                      │\n│       \"celestial_body_name\": \"Марс\",                         │\n│       ...                                                    │\n│     }                                                        │\n└──────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## ✅ КОНТРОЛЬНЫЕ ВОПРОСЫ\n\nОтветь для закрепления:\n\n1. **Откуда берётся `observation_id`?**\n2. **Что делает `await db.execute()`?**\n3. **Что вернёт `scalar_one_or_none()`, если запись не найдена?**\n4. **Зачем нужны 3 запроса к БД (наблюдение, астроном, тело)?**\n5. **Что такое `**observation.model_dump()`?**\n6. **Что означает `if astronomer else None`?**\n\n---\n\n## 💡 ГЛАВНОЕ, ЧТО НУЖНО ЗАПОМНИТЬ\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  @router.get()      → Регистрирует маршрут                  │\n│  observation_id     → Берётся из URL                        │\n│  Depends(get_db)    → Даёт сессию БД                        │\n│  select().where()   → Создаёт SQL запрос                    │\n│  await db.execute() → Выполняет запрос                      │\n│  scalar_one_or_none()→ Получает одну запись или None        │\n│  if not observation:→ Проверка на существование             │\n│  model_dump()       → Объект → dict                         │\n│  **dict             → Распаковка в аргументы                │\n│  return response    → Отправка JSON клиенту                 │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Жду твои ответы на вопросы!** 📝"}
	],
	"edges":[
		{"id":"74a76eed226573bc","fromNode":"9e0a2b583fa82bcf","fromSide":"left","toNode":"32d71c9b6d6f33d3","toSide":"left"},
		{"id":"f40485413ce56c30","fromNode":"7f61592ae113c6a3","fromSide":"left","toNode":"0ec11a2f66a6bd64","toSide":"left","fromEnd":"arrow"}
	]
}